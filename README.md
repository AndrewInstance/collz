# Collz
Custom Scala Collections

TODO english docs in few months

## Библиотека коллекций для Scala
Библиотека коллекций, которых может недоставать в стандартной библиотеке Scala. 
Пока находится в разработке и будет готова в течении нескольких месяцев. 
В данный момент содержит следующие коллекции:  
1. Мутабельные:  
    a. VList      
    b. BoundedQueue  
    c. IntMap  
    d. IntSet  
    e. PrefixMap  
    f. PrefixSet  
2. Иммутабельные:  
    a. BoundedQueue   
    b. PrefixTree  
    
## Описание реализаций
Все мутабельные коллекции не являются потокобезопасными

### <a name="vlist"></a> VList
Класс как возможная альтернатива ListBuffer или ArrayBuffer

Представляет собой список из массивов, каждый следующий больше предыдущего в 2 раза. 
Что позволяет получить логарифмическое время доступа к элементу по индексу 
и константное время добавления в конец. В данной реализации список заменен на массив-буфер с 
запасом, что позволяет реализовать эффективные алгоритмы для итераций в прямом и 
обратном направлениях. В связи с этим сложность добавления в конец стала O(log(log(n))),
что примерно ~O(1).
 
Данная реализация является буфером, но также наследует immutable.Seq, чтобы можно было использовать
в некоторых приложения.

К сожалению из википедии удалили статьи об этой структуре данных и не могу тут расположить ссылку.

### <a name="fixed_queue"></a> BoundedQueue
Прдеставляет собой коллекцию очередь типа FIFO с фиксированным размером. 
Новые элементы добавляются в клонец методами push.
Элементы из очереди получаются вызовами методов pull из начала. 
При превышении размера удаляются элементы из начала. Реализована с очень быстрым добавлением
в начало и в конец. Также реализовано с очень быстрым доступом по индексу и быстрыми итерациями по 
очереди.  

Внутри реализовано с помощью двух массивов с размером, равным размеру очереди. 
В первом массиве есть указатели на начало и конец очереди, а во втором массиве только указатель на
конец. (тут указателем называется номер индекса).
При перепонии первого моссива начинает заполнятся второй.
Когда второй массив доходи до конца или когда кончается первый массив, тогда второй
заменяет собой первый. Такой подход позволяет реализовать множество операций эфективным
образом. 

иммутабельные реализованы схожим образом. Только вместо массивов используется класс Vector

### <a name="int_map"></a> IntMap
В стандартной библиотеке Scala есть эффективная неизменяемая реализация IntMap. Тут же
преставлена эффективная изменяемая реализация. Основана на Prefix Tree, Trie или Patricia Tree 
или еще как-нибудь. Очень близка к иммутабельной реазации HashMap, но имеет сильно более 
упрощенный вид. При поиске по элементу бенчмарки большой разницы по сравнению из 
мутабельными AnyRefMap, HashMap и тд. Но скорость добавления и удаления элементов 
может быть в 4-8 раз быстрее. Сложность операций добавления, удаления, поиска имеет  вид 
O(log16(n))

### <a name="int_map"></a> IntSet
Реализация mutable.Set[_], оптимизированная для работы с Int. Сделана на базе префиксных деревьев. 
Представляет собой легкую обертку поверх IntMap. 


### <a name="prefix_map"></a> PrefixMap
Реализация mutable.Map[_, _], оптимизированная для работы со строками. 
Сделана в виде префиксных деревьев. Для быстрого поиска элемента в узле, каждый узел содержит
IntMap, что позволяет получить худшее возможное время поиска мало зависящим от колличества элементов
в коллекции, а зависящим только от длинны ключа. Время поиска в худшем случае примерно равно времени
поиска в лучшем случае в хэш таблице и разница будет тем больше, чем длиннее ключ. Для строк типа URL
можно получить более чем 2-кратный прирост в скорости по сравнению с хэш таблицей.
Данная реализация значительно более эффективна, чем иммутабельная версия в PrefixTree

### <a name="prefix_map"></a> PrefixSet
Реализация mutable.Set[_], оптимизированная для работы со строками. 
Сделана в виде префиксных деревьев. Реализована в виде тонкой обертки вокруг PrefixMap.

### <a name="prefix_tree"></a> PrefixTree 
Реализация immutable.Set[_] для работы со строками на базе префиксного дерева. Позволяет
выполнять эффективный поиск поиск, добавление и удаление при работе со строками. В случае
со строками, которые содержат большие одинаковые куски, например, разного рода URL, может
быть в несколько раз быстрее чем другие реализации Set при поиске.

Пока что реализация не очень эффективна и требует улучшения,
так как операции внутри узлов занимают время О(n) в зависимости от количества 
элементов в узле. В дальнейшем может притерпеть сильные изменения в реализации, но интерфейс
должен остаться прежним.

## Roadmap
1. Сделать нормальную документацию, в основном на англ языке, добавить примеры кода
(English docs)
2. Привести к нормальному виду тесты
(Refactor tests)
3. Поменять на более эфективную реализацию PrefixTree -- заменить списки листьев в узлах на IntMap
4. Добавить новые коллекции 
    1) иммутабельные:  
        a. PrefixSet   
        b. PrefixMap  
        c. NonDeleteBoundedQueue
    2) мутабельные:  
        a. PrefixSet    
        b. PrefixMap  
        c. NonDeleteBoundedQueue  
        d. IntervalMap
5. Добавить бенчмарки в репозиторий
6. Добавить описание лицензии
7. Добавить Тревис
8. Залить в Мавен/Сонатайп или куда-нибудь еще
9. в PrefixMap добавить поиск по префиксу.

    
        
